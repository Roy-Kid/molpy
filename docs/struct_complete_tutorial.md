# Complete Struct Module Tutorial## OverviewThe Struct module is the core of the MolPy framework, providing fundamental data types for representing and manipulating molecular structures. This tutorial will guide you from basic usage to advanced extensions, covering all core functionality.## 1. Basic Concepts### 1.1 Entity SystemAll MolPy objects inherit from the `Entity` class, providing flexible attribute storage:```pythonimport molpy as mpimport numpy as np# Create basic entityentity = mp.Entity(name="example", type="test")# Dictionary-style accessprint(entity["name"])  # "example"# Dynamic property additionentity["dynamic_prop"] = [1, 2, 3]print(entity["dynamic_prop"])  # [1, 2, 3]# Clone and modifynew_entity = entity.clone(name="modified", value=42)print(new_entity["name"])  # "modified"print(new_entity["value"])  # 42# Shortcut call syntaxanother_entity = entity(name="another", extra="data")```**Core Features:**- Flexible attribute storage- Dictionary-style access support- Deep copy and modification functionality- Object identity-based hashing and comparison- Support for `__call__` shortcut syntax### 1.2 Spatial EntitiesEntities with spatial coordinates inherit from `SpatialMixin`:```python# Atoms are spatial entitiesatom = mp.Atom(name="C1", element="C", xyz=[0.0, 0.0, 0.0])# Coordinate access and modificationprint(atom.xyz)  # [0. 0. 0.]atom.xyz = [1.0, 2.0, 3.0]print(atom.xyz)  # [1. 2. 3.]# Spatial operationsatom.move([1.0, 0.0, 0.0])  # Translationprint(atom.xyz)  # [2. 2. 3.]# Rotation (90 degrees around z-axis)atom.rotate(np.pi/2, [0, 0, 1])# Reflectionatom.reflect([1, 0, 0])  # Reflect across x=0 plane# Distance calculationatom2 = mp.Atom(name="C2", xyz=[5.0, 2.0, 3.0])distance = atom.distance_to(atom2)print(f"Distance: {distance:.2f}")```**Spatial Operations:**- `move(vector)`: Translation by vector- `rotate(angle, axis)`: Rotation around axis by angle (radians)- `reflect(normal)`: Reflection across plane defined by normal- `distance_to(other)`: Distance calculation to another spatial entity### 1.3 Coordinate SystemMolPy uses a right-handed Cartesian coordinate system:- X-axis: typically molecular width direction- Y-axis: typically molecular height direction  - Z-axis: follows right-hand rule (X × Y = Z)- Units: Angstroms (Å) by default## 2. Atoms - Basic Building Blocks### 2.1 Creating Atoms```python# Basic atom creationcarbon = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])# With additional propertiesoxygen = mp.Atom(    name="O1",     element="O",     xyz=[1.4, 0, 0],    charge=-0.4,    mass=15.999,    atom_type="O.3")# Using atomic numberhydrogen = mp.Atom(name="H1", atomic_number=1, xyz=[0, 1, 0])print(f"Carbon: {carbon}")print(f"Oxygen element: {oxygen['element']}")print(f"Hydrogen atomic number: {hydrogen['atomic_number']}")```### 2.2 Atom PropertiesAtoms support both common and custom properties:```pythonatom = mp.Atom(name="N1", element="N")# Standard propertiesatom["mass"] = 14.007atom["charge"] = -0.3atom["atom_type"] = "N.am"atom["residue"] = "ALA"# Custom propertiesatom["custom_prop"] = "custom_value"atom["energy"] = -100.5atom["is_aromatic"] = True# Property accessprint(f"Mass: {atom['mass']}")print(f"Custom property: {atom['custom_prop']}")# Check property existenceif "charge" in atom:    print(f"Atom has charge: {atom['charge']}")```### 2.3 Atom Operations```python# Create atoms for manipulationatom1 = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])atom2 = mp.Atom(name="C2", element="C", xyz=[1.5, 0, 0])# Distance calculationdistance = atom1.distance_to(atom2)print(f"C-C distance: {distance:.2f} Å")# Clone atomsnew_atom = atom1.clone(name="C3", xyz=[0, 1.5, 0])print(f"Cloned atom: {new_atom['name']} at {new_atom.xyz}")# Spatial transformationsatom1.move([0, 0, 1])  # Move up 1 Åatom2.rotate(np.pi/4, [0, 0, 1])  # Rotate 45° around z-axisprint(f"After transformation:")print(f"Atom1: {atom1.xyz}")print(f"Atom2: {atom2.xyz}")```## 3. Bonds - Connecting Atoms### 3.1 Creating Bonds```python# Create two atomsc1 = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])c2 = mp.Atom(name="C2", element="C", xyz=[1.5, 0, 0])# Create bondbond = mp.Bond(c1, c2, bond_type="single", bond_order=1)print(f"Bond atoms: {bond.atoms}")print(f"Bond type: {bond['bond_type']}")print(f"Bond order: {bond['bond_order']}")# Access individual atomsatom1, atom2 = bond.atomsprint(f"First atom: {atom1['name']}")print(f"Second atom: {atom2['name']}")```### 3.2 Bond Properties```python# Bond with multiple propertiesbond = mp.Bond(    c1, c2,    bond_type="aromatic",    bond_order=1.5,    length=1.39,    force_constant=500.0,    is_rotatable=False)# Calculate current lengthcurrent_length = bond.lengthprint(f"Calculated bond length: {current_length:.3f} Å")print(f"Specified bond length: {bond['length']:.3f} Å")# Bond propertiesprint(f"Bond type: {bond['bond_type']}")print(f"Force constant: {bond['force_constant']}")print(f"Rotatable: {bond['is_rotatable']}")```### 3.3 Bond Geometry```python# Create bonds for geometry analysiso = mp.Atom(name="O", element="O", xyz=[0, 0, 0])h1 = mp.Atom(name="H1", element="H", xyz=[0.757, 0.586, 0])h2 = mp.Atom(name="H2", element="H", xyz=[-0.757, 0.586, 0])bond1 = mp.Bond(o, h1)bond2 = mp.Bond(o, h2)print(f"O-H1 length: {bond1.length:.3f} Å")print(f"O-H2 length: {bond2.length:.3f} Å")# Bond vector (from first to second atom)vector1 = bond1.vectorvector2 = bond2.vectorprint(f"Bond1 vector: {vector1}")print(f"Bond2 vector: {vector2}")```## 4. Angles and Dihedrals### 4.1 Angle Creation and Properties```python# Create atoms for anglec1 = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])o = mp.Atom(name="O", element="O", xyz=[1, 0, 0]) c2 = mp.Atom(name="C2", element="C", xyz=[2, 1, 0])# Create angleangle = mp.Angle(c1, o, c2, angle_type="ether")print(f"Angle atoms: {[atom['name'] for atom in angle.atoms]}")print(f"Angle value: {angle.angle:.1f}°")print(f"Angle in radians: {angle.angle_radians:.3f}")# Angle propertiesangle["force_constant"] = 100.0angle["equilibrium_angle"] = 109.5print(f"Equilibrium angle: {angle['equilibrium_angle']}°")```### 4.2 Dihedral Angles```python# Create atoms for dihedralc1 = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])c2 = mp.Atom(name="C2", element="C", xyz=[1, 0, 0])c3 = mp.Atom(name="C3", element="C", xyz=[2, 1, 0])c4 = mp.Atom(name="C4", element="C", xyz=[3, 1, 1])# Create dihedraldihedral = mp.Dihedral(c1, c2, c3, c4, dihedral_type="sp3-sp3")print(f"Dihedral atoms: {[atom['name'] for atom in dihedral.atoms]}")print(f"Dihedral angle: {dihedral.angle:.1f}°")# Dihedral propertiesdihedral["periodicity"] = 3dihedral["phase"] = 0.0dihedral["force_constant"] = 1.0```### 4.3 Geometric Calculations```python# Water molecule geometryo = mp.Atom(name="O", element="O", xyz=[0, 0, 0])h1 = mp.Atom(name="H1", element="H", xyz=[0.757, 0.586, 0])h2 = mp.Atom(name="H2", element="H", xyz=[-0.757, 0.586, 0])# H-O-H anglewater_angle = mp.Angle(h1, o, h2)print(f"H-O-H angle: {water_angle.angle:.1f}°")# Expected tetrahedral angleexpected_angle = 109.5difference = abs(water_angle.angle - expected_angle)print(f"Deviation from tetrahedral: {difference:.1f}°")```## 5. Molecular Structures### 5.1 Creating AtomicStructure```python# Create empty structuremolecule = mp.AtomicStructure(name="water")# Add atoms directlyo = molecule.def_atom(name="O", element="O", xyz=[0, 0, 0])h1 = molecule.def_atom(name="H1", element="H", xyz=[0.757, 0.586, 0])h2 = molecule.def_atom(name="H2", element="H", xyz=[-0.757, 0.586, 0])print(f"Molecule name: {molecule['name']}")print(f"Number of atoms: {len(molecule.atoms)}")print(f"Atom names: {[atom['name'] for atom in molecule.atoms]}")```### 5.2 Adding Bonds and Topology```python# Add bonds to the structurebond1 = molecule.def_bond(o, h1, bond_type="covalent")bond2 = molecule.def_bond(o, h2, bond_type="covalent")print(f"Number of bonds: {len(molecule.bonds)}")# Add angleangle = mp.Angle(h1, o, h2, angle_type="bent")molecule.add_angle(angle)print(f"Number of angles: {len(molecule.angles)}")print(f"H-O-H angle: {angle.angle:.1f}°")```### 5.3 Structure Properties and Analysis```python# Calculate molecular propertiesmolecule = mp.AtomicStructure(name="methane")# Build methane structurec = molecule.def_atom(name="C", element="C", xyz=[0, 0, 0])h1 = molecule.def_atom(name="H1", element="H", xyz=[1.09, 0, 0])h2 = molecule.def_atom(name="H2", element="H", xyz=[-0.363, 1.027, 0])h3 = molecule.def_atom(name="H3", element="H", xyz=[-0.363, -0.513, 0.889])h4 = molecule.def_atom(name="H4", element="H", xyz=[-0.363, -0.513, -0.889])# Add all bondsfor h in [h1, h2, h3, h4]:    molecule.def_bond(c, h, bond_type="single")# Calculate center of masscom = molecule.center_of_mass()print(f"Center of mass: {com}")# Get all coordinatescoords = molecule.coordinatesprint(f"Molecular coordinates shape: {coords.shape}")# Molecular formulaformula = molecule.molecular_formula()print(f"Molecular formula: {formula}")```### 5.4 Structure Manipulation```python# Create benzene ring structurebenzene = mp.AtomicStructure(name="benzene")# Add carbon atoms in hexagonal arrangementimport mathradius = 1.4  # C-C bond lengthcarbon_atoms = []for i in range(6):    angle = i * math.pi / 3    x = radius * math.cos(angle)    y = radius * math.sin(angle)    z = 0.0        atom = benzene.def_atom(        name=f"C{i+1}",         element="C",         xyz=[x, y, z]    )    carbon_atoms.append(atom)# Add ring bondsfor i in range(6):    next_i = (i + 1) % 6    benzene.def_bond(        carbon_atoms[i],         carbon_atoms[next_i],         bond_type="aromatic",        bond_order=1.5    )print(f"Benzene atoms: {len(benzene.atoms)}")print(f"Benzene bonds: {len(benzene.bonds)}")# Transform entire structurebenzene.move([0, 0, 5])  # Move upbenzene.rotate(math.pi/4, [0, 0, 1])  # Rotate 45°print("Benzene structure built and transformed!")```## 6. Advanced Features### 6.1 Hierarchical Structures```python# Create complex molecular systemprotein = mp.AtomicStructure(name="mini_protein")# Add multiple residuesresidues = []for i in range(3):    # Simple residue representation    residue = mp.AtomicStructure(name=f"RES{i+1}")        # Add backbone atoms    n = residue.def_atom(name="N", element="N", xyz=[i*3.8, 0, 0])    ca = residue.def_atom(name="CA", element="C", xyz=[i*3.8+1.5, 0, 0])    c = residue.def_atom(name="C", element="C", xyz=[i*3.8+3, 0, 0])    o = residue.def_atom(name="O", element="O", xyz=[i*3.8+3, 1.2, 0])        # Add bonds    residue.def_bond(n, ca)    residue.def_bond(ca, c)    residue.def_bond(c, o)        residues.append(residue)# Connect residues (simplified)for i in range(len(residues)-1):    # Get C atom from current residue and N from next    c_atom = residues[i].get_atom(name="C")    n_atom = residues[i+1].get_atom(name="N")    # In real implementation, would add peptide bond    print(f"Created {len(residues)} residues")```### 6.2 Performance Optimization```python# Efficient batch operationsstructure = mp.AtomicStructure(name="large_system")# Create many atoms efficientlyatom_data = []for i in range(1000):    atom_data.append({        'name': f'A{i}',        'element': 'C',        'xyz': [i*0.1, 0, 0]    })# Batch add atoms (hypothetical efficient method)# In practice, might use Frame for such operationsatoms = [structure.def_atom(**data) for data in atom_data]print(f"Created {len(atoms)} atoms")# Efficient coordinate accessall_coords = structure.coordinatesprint(f"Coordinate array shape: {all_coords.shape}")# Vectorized operationscenter = np.mean(all_coords, axis=0)centered_coords = all_coords - center```### 6.3 Integration with Frame```python# Convert structure to Frame for analysiswater = mp.AtomicStructure(name="water")o = water.def_atom(name="O", element="O", xyz=[0, 0, 0])h1 = water.def_atom(name="H1", element="H", xyz=[0.757, 0.586, 0])h2 = water.def_atom(name="H2", element="H", xyz=[-0.757, 0.586, 0])# Convert to Frame (hypothetical)frame = water.to_frame()print(f"Frame keys: {list(frame.keys())}")# Perform analysis in Frame# coords = frame['atoms'].coords['xyz']# distances = calculate_distance_matrix(coords)# Convert back to structure# new_structure = frame.to_structure()```## 7. Best Practices### 7.1 Naming Conventions```python# Use consistent naming# Good:atom = mp.Atom(name="CA_1", element="C")bond = mp.Bond(atom1, atom2, bond_type="single")# Avoid:# atom = mp.Atom(name="carbon atom 1", element="C")  # Spaces in names# bond = mp.Bond(atom1, atom2, type="single")        # Inconsistent parameter names```### 7.2 Memory Management```python# For large structures, consider using Frame# Struct objects for detailed manipulation# Frame objects for bulk operations and analysis# Clean up references when doneatoms = Nonebonds = Nonestructure = None```### 7.3 Error Handling```pythontry:    atom = mp.Atom(name="C1", element="C", xyz=[0, 0, 0])    bond = mp.Bond(atom, atom)  # Self-bond might be invalidexcept ValueError as e:    print(f"Invalid bond: {e}")# Check properties before accessif "charge" in atom:    charge_value = atom["charge"]else:    charge_value = 0.0  # Default value```## 8. Common Use Cases### 8.1 Drug-like Molecule```python# Create simple drug-like moleculedrug = mp.AtomicStructure(name="aspirin_fragment")# Add aromatic ring (simplified)ring_atoms = []for i in range(6):    atom = drug.def_atom(name=f"C{i+1}", element="C", xyz=[i, 0, 0])    ring_atoms.append(atom)# Add functional groupscarboxyl_c = drug.def_atom(name="C7", element="C", xyz=[6, 1, 0])carboxyl_o1 = drug.def_atom(name="O1", element="O", xyz=[7, 1, 0])carboxyl_o2 = drug.def_atom(name="O2", element="O", xyz=[6, 2, 0])# Add bondsfor i in range(5):    drug.def_bond(ring_atoms[i], ring_atoms[i+1])drug.def_bond(ring_atoms[5], ring_atoms[0])  # Close ringdrug.def_bond(ring_atoms[0], carboxyl_c)drug.def_bond(carboxyl_c, carboxyl_o1)drug.def_bond(carboxyl_c, carboxyl_o2)print(f"Drug molecule: {len(drug.atoms)} atoms, {len(drug.bonds)} bonds")```### 8.2 Polymer Chain```python# Create polymer chainpolymer = mp.AtomicStructure(name="polyethylene_chain")# Monomer unit: -CH2-CH2-monomers = 10chain_atoms = []for i in range(monomers):    # Add two carbons per monomer    c1 = polymer.def_atom(        name=f"C{2*i+1}",         element="C",         xyz=[i*2.5, 0, 0]    )    c2 = polymer.def_atom(        name=f"C{2*i+2}",         element="C",         xyz=[i*2.5+1.25, 0, 0]    )        chain_atoms.extend([c1, c2])        # Bond within monomer    polymer.def_bond(c1, c2)        # Bond to previous monomer    if i > 0:        prev_c2 = chain_atoms[2*i-1]        polymer.def_bond(prev_c2, c1)print(f"Polymer chain: {len(polymer.atoms)} atoms")```### 8.3 Crystal Structure```python# Simple cubic crystalcrystal = mp.AtomicStructure(name="simple_cubic")# Crystal parameterslattice_constant = 4.0size = 3  # 3x3x3 unit cellsfor i in range(size):    for j in range(size):        for k in range(size):            atom = crystal.def_atom(                name=f"A_{i}_{j}_{k}",                element="Na",                xyz=[i*lattice_constant, j*lattice_constant, k*lattice_constant]            )print(f"Crystal structure: {len(crystal.atoms)} atoms")# Calculate unit cell volumevolume = lattice_constant ** 3print(f"Unit cell volume: {volume:.1f} Ų")```## SummaryThe Struct module provides a comprehensive framework for molecular structure representation:- **Entity System**: Flexible property storage and manipulation- **Spatial Operations**: Complete 3D geometric operations- **Hierarchical Design**: From atoms to complex molecular systems- **Performance**: Optimized for both small molecules and large systems- **Integration**: Seamless conversion to Frame for data analysisThis tutorial covered the essential concepts and practical usage patterns. For more advanced features and integration with other MolPy modules, refer to the API documentation and examples collection.